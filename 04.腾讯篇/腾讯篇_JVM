### JVM
4.4.2 什么情况下会发生栈内存溢出。
  内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。
  一）是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；
  二）是否 应用 中使用了大量的递归或无限递归
  三）是否App中使用了大量循环或死循环
  四）检查 应用 中是否使用了向数据库查询所有记录的方法。
  五）检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。
  六）检查是否使用了“非字面量字符串进行+”的操作。
4.4.3 JVM的内存结构，Eden和Survivor比例。
    JVM内存的结构为
    堆：存放对象
    栈：运行时存放栈帧
    程序计数器
    方法区：存放类和常量
    Eden区是一块，Survivor区是两块。
    Eden区和Survivor区的比例是8：1：1
4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
      1、Minor GC是发生在新生代中的垃圾收集，采用的复制算法；
      2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；
      3、Minor GC每次收集后Eden区和一块Survivor区都被清空；
      4、老年代中使用Full GC，采用的标记-清除算法
4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
    对象诞生即新生代->eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记。当一个对象存活默认超过15次都没有被回收掉，就会进入老年代。
    -Xmx3550m： 最大堆大小为3550m。
    -Xms3550m： 设置初始堆大小为3550m。
    -Xmn2g： 设置年轻代大小为2g。
    -Xss128k： 每个线程的堆栈大小为128k。
    -XX:MaxPermSize：  设置持久代大小为16m
    -XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
    -XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
    -XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。
    -XX:+UseParallelGC： 选择垃圾收集器为并行收集器。
    -XX:ParallelGCThreads=20： 配置并行收集器的线程数
    -XX:+UseConcMarkSweepGC： 设置年老代为并发收集。
    -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
    -XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片
4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
     Serial收集器是一个新生代收集器，单线程执行，使用复制算法。Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，适用于单cpu机器的场景
    ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。
    Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。
    CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，适用于集中在互联网站或者B/S系统的服务端的Java应用。
    ①.初始标记(CMS initial mark)
    ②.并发标记(CMS concurrenr mark)
    ③.重新标记(CMS remark)
    ④.并发清除(CMS concurrent sweep)
    G1具备如下特点：
    并行与并发：分代收集：空间整合：可预测的停顿：
4.4.7 垃圾回收算法的实现原理。
    引用计数法
    标记-清除
    标记-压缩
    复制算法
    分代思想
4.4.8 当出现了内存溢出，你怎么排错。
    内存溢出是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于虚拟机能提供的最大内存。
    第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
　　 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
　　 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
    Profiler 工具主要用于检查和跟踪系统（限于 Java 开发的）的性能。
4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
    https://blog.csdn.net/hanchao5272/article/details/79575491
    每个线程都拥有自己的线程栈。
    线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。
    线程栈还包含了当前方法的所有本地变量信息。
    一个线程只能读取自己的线程栈，每个线程中的本地变量都会有自己的版本，线程中的本地变量对其它线程是不可见的。
    所有原始类型(8种)的本地变量都直接保存在线程栈当中，线程可以传递原始类型的副本给另一个线程，线程之间无法共享原始类型的本地变量。
    堆区包含了Java应用创建的所有对象信息。
    堆区包含了所有线程创建的对象信息。
    堆区包含了原始类型的封装类（如Byte、Integer、Long等等）的对象信息。

    在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。
    编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
    通过内存屏障禁止重排序：JMM通过插入特定类型的内存屏障，来禁止特定类型的编译器重排序和处理器重排序。

  内存屏障
    内存屏障或内存栅栏(Memory Barrier)，是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。
    内存屏障有两个能力：
    就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的有序性。
    强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的可见性。
    内存屏障有三种类型和一种伪类型：
  lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
  sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
  mfence，即全能屏障，具备ifence和sfence的能力。
  Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能。
  
4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
    类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。如果站在JVM的角度来看，只存在两种类加载器。启动类加载器，其他类加载器
    双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
    打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。
4.5.1 讲讲JAVA的反射机制。
    反射可以帮助我们在动态运行的时候，对于任意一个类，可以获得其所有的方法（包括 public protected private 默认状态的），所有的变量 （包括 public protected private 默认状态的）。
4.5.2 你们线上应用的JVM参数有哪些。
4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
4.5.4 怎么打出线程栈信息。
  jstack  pid

