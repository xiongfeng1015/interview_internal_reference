### JVM
4.4.2 什么情况下会发生栈内存溢出。
  内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。
  一）是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；
  二）是否 应用 中使用了大量的递归或无限递归
  三）是否App中使用了大量循环或死循环
  四）检查 应用 中是否使用了向数据库查询所有记录的方法。
  五）检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。
  六）检查是否使用了“非字面量字符串进行+”的操作。
4.4.3 JVM的内存结构，Eden和Survivor比例。
    JVM内存的结构为
    堆：存放对象
    栈：运行时存放栈帧
    程序计数器
    方法区：存放类和常量
    Eden区是一块，Survivor区是两块。
    Eden区和Survivor区的比例是8：1：1
4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
      1、Minor GC是发生在新生代中的垃圾收集，采用的复制算法；
      2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；
      3、Minor GC每次收集后Eden区和一块Survivor区都被清空；
      4、老年代中使用Full GC，采用的标记-清除算法
4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
    对象诞生即新生代->eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记。当一个对象存活默认超过15次都没有被回收掉，就会进入老年代。
    -Xmx3550m： 最大堆大小为3550m。
    -Xms3550m： 设置初始堆大小为3550m。
    -Xmn2g： 设置年轻代大小为2g。
    -Xss128k： 每个线程的堆栈大小为128k。
    -XX:MaxPermSize：  设置持久代大小为16m
    -XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
    -XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
    -XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。
    -XX:+UseParallelGC： 选择垃圾收集器为并行收集器。
    -XX:ParallelGCThreads=20： 配置并行收集器的线程数
    -XX:+UseConcMarkSweepGC： 设置年老代为并发收集。
    -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
    -XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片
4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
4.4.7 垃圾回收算法的实现原理。
4.4.8 当出现了内存溢出，你怎么排错。
4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
4.5.1 讲讲JAVA的反射机制。
4.5.2 你们线上应用的JVM参数有哪些。
4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
4.5.4 怎么打出线程栈信息。

